//Illusory Software | IDA SigMaker For All Platforms. (.idc)

#include <idc.idc>



static GenerateSignature(start, end) 
{
    auto signature = "";
    auto separator = " ";
    auto addr;
    
    for (addr = start; addr < end; addr++) 
    {
        auto loop;
        auto byteValue = Byte(addr);
        auto op_size = isOpcodeX(addr, byteValue);
        auto mnem = instruction_type(addr);
        auto instructionSize = ItemSize(addr);
        Message("Instruction at 0x%x (%s) with size %d\n", addr, mnem, op_size);
        if (op_size == 0){ continue; }
        

        signature = signature + separator + ByteToHex(byteValue);
        for (loop = 1; loop < op_size; loop++)
        {
            if (mnem == "lea" && instructionSize == 5 && loop < 2)
            {
                byteValue = Byte(addr+loop);
                signature = signature + separator + ByteToHex(byteValue);
            }
            else if (mnem == "lea" && instructionSize == 7 && loop < 2)
            {
                byteValue = Byte(addr+loop);
                signature = signature + separator + ByteToHex(byteValue);
            }
            else if (mnem == "mov" && instructionSize == 3)
            {
                byteValue = Byte(addr+loop);
                signature = signature + separator + ByteToHex(byteValue);
            }
            else if (mnem == "sub" && instructionSize == 7 && loop < 2)
            {
                byteValue = Byte(addr+loop);
                signature = signature + separator + ByteToHex(byteValue);
            }
            else
            {
                signature = signature + separator + "?";
            }    
        }
        addr = addr+(op_size-1);
    }

    return signature;
}

static isOpcodeX(addr, byteValue) 
{ 
    auto address = addr;
    auto instructionSize = ItemSize(address);
    //auto operandType = get_operand_type(address, operandIndex);

    return instructionSize;
}


static instruction_type(address)
{
    auto mnem =  print_insn_mnem(address);

    return mnem;
}

static ByteToHex(byteValue) 
{
    auto hex = "0123456789ABCDEF";
    return hex[(byteValue >> 4) & 0xF] + hex[byteValue & 0xF];
}

static StartSigMaker()
{
    auto selection_start = SelStart();
    auto selection_end = SelEnd();
    
    if (selection_start == BADADDR || selection_end == BADADDR) 
    {
        Message("Please select a valid block of data first.\n");
    } 
    else 
    {
        auto signature = GenerateSignature(selection_start, selection_end);
        Message("Generated Byte Array Signature: %s\n\n", signature);
    }
}

static ShowYesNoPrompt() {
    auto choice = AskYN(1, "Do you want to continue and generate a signature?");
    return choice;
}

static IllusorySigMaker() 
{
    auto prompt = ShowYesNoPrompt();
    if (prompt == 1) {
        Message("User selected Yes.\n");
        StartSigMaker();
    } else if (prompt == 0){
        Message("User selected No.\n");
    }
    else if (prompt == -1){
        Message("User selected Cancel.\n");
    }
}

static main()
{
    
    AddHotkey("Ctrl-Alt-S", "IllusorySigMaker");

}
